{"post_stream":{"posts":[{"id":14287,"name":"","username":"artgolf1000","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","created_at":"2016-11-03T07:39:46.000Z","cooked":"\u003cp\u003eHi,\u003c/p\u003e\n\u003cp\u003eI have ported \u003ca href=\"http://www.alexandre-pestana.com/volumetric-lights/\" data-bbcode=\"true\" rel=\"nofollow noopener\"\u003ehttp://www.alexandre-pestana.com/volumetric-lights/\u003c/a\u003e into ‚Äòforwardlights‚Äô command, it works, but still has some issues.\u003cbr\u003e\nI have commented the second ‚Äòforwardlights‚Äô command now, it will override generated volumetric light QUAT unexpectedly.\u003c/p\u003e\n\u003cp\u003eEdit: The engine does not support multiply forward lighting passes, so I have to use the alpha channel to store the volumetric light value instead.\u003c/p\u003e","post_number":1,"post_type":1,"updated_at":"2017-01-02T01:15:02.032Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":359,"reads":61,"readers_count":60,"score":1809.2,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"http://www.alexandre-pestana.com/volumetric-lights/","internal":false,"reflection":false,"clicks":73},{"url":"http://discourse.urho3d.io/t/anyone-could-use-urho3d-depth-on-raymarching-in-shaders/3084/2","internal":true,"reflection":true,"title":"Anyone could use Urho3D Depth on Raymarching in Shaders?","clicks":1}],"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":546,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14288,"name":"","username":"franck22000","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/f/f4b2a3/{size}.png","created_at":"2016-11-03T09:34:30.000Z","cooked":"\u003cp\u003eNice, do you have any screenshots or video to show ?\u003c/p\u003e\n\u003cp\u003eAre you planning to do this for deferred renderpath ?\u003c/p\u003e","post_number":2,"post_type":1,"updated_at":"2017-01-02T01:15:02.094Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":3,"reads":60,"readers_count":59,"score":27.0,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":174,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14289,"name":"","username":"artgolf1000","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","created_at":"2016-11-03T13:56:45.000Z","cooked":"\u003cp\u003eI‚Äôll try deferred render-path tomorrow, no screenshots or videos yet.\u003c/p\u003e","post_number":3,"post_type":1,"updated_at":"2017-01-02T01:15:02.155Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":6,"reads":64,"readers_count":63,"score":42.8,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":546,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14294,"name":"","username":"artgolf1000","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","created_at":"2016-11-04T05:03:22.000Z","cooked":"\u003cp\u003eFigure it out! It works in both forward mode and deferred mode now!\u003c/p\u003e\n\u003cp\u003eIt support multiple directional lights, point lights and spot lights casting shadows, but use only one light to cast shadow is recommended.\u003c/p\u003e\n\u003cp\u003eTo test volumetric lighting effect, just replace the original files with the modified version, the volumetric lighting effect should appears.\u003c/p\u003e\n\u003cp\u003eThe forward mode can run on mobile devices, if you use only one directional light to cast shadow, the performance is excellent, I notice no cpu increase.\u003c/p\u003e\n\u003cp\u003eThis demo has one directional light behind a wall, light beams come through the windows, you can see the volumetric lighting effect when light direction changes.\u003c/p\u003e\n\u003cp\u003eYoutube: \u003ca href=\"https://youtu.be/ZkkazPduyW4\" data-bbcode=\"true\" rel=\"nofollow noopener\"\u003ehttps://youtu.be/ZkkazPduyW4\u003c/a\u003e\u003cbr\u003e\n[video]\u003ca href=\"https://youtu.be/ZkkazPduyW4%5B/video%5D\" rel=\"nofollow noopener\"\u003ehttps://youtu.be/ZkkazPduyW4[/video]\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eForward.xml:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;renderpath\u0026gt;\n    \u0026lt;rendertarget name=\"fullscreen\" sizedivisor=\"1 1\" format=\"rgba\" filter=\"true\" /\u0026gt;\n    \u0026lt;command type=\"clear\" color=\"0 0 0 0\" depth=\"1.0\" stencil=\"0\" output=\"fullscreen\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"base\" vsdefines=\"VOLUMETRICLIGHT\" psdefines=\"VOLUMETRICLIGHT\" vertexlights=\"true\" metadata=\"base\" output=\"fullscreen\" /\u0026gt;\n    \u0026lt;command type=\"forwardlights\" pass=\"light\" vsdefines=\"VOLUMETRICLIGHT\" psdefines=\"VOLUMETRICLIGHT\" output=\"fullscreen\" /\u0026gt;\n    \u0026lt;rendertarget name=\"blurv\" tag=\"Bloom\" sizedivisor=\"4 4\" format=\"rgb\" filter=\"true\" /\u0026gt;\n    \u0026lt;rendertarget name=\"blurh\" tag=\"Bloom\" sizedivisor=\"4 4\" format=\"rgb\" filter=\"true\" /\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BRIGHT VOLUMETRICLIGHT\" output=\"blurv\"\u0026gt;\n        \u0026lt;parameter name=\"BloomThreshold\" value=\"0.0\" /\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"fullscreen\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BLURH\" output=\"blurh\"\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"blurv\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BLURV\" output=\"blurv\"\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"blurh\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"COMBINE\" output=\"viewport\"\u0026gt;\n        \u0026lt;parameter name=\"BloomMix\" value=\"1.0 1.0\" /\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"fullscreen\" /\u0026gt;\n        \u0026lt;texture unit=\"normal\" name=\"blurv\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"postopaque\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"refract\"\u0026gt;\n        \u0026lt;texture unit=\"environment\" name=\"viewport\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"alpha\" vertexlights=\"true\" sort=\"backtofront\" metadata=\"alpha\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"postalpha\" sort=\"backtofront\" /\u0026gt;\n\u0026lt;/renderpath\u0026gt;\n\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eDeferred.xml:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;renderpath\u0026gt;\n    \u0026lt;rendertarget name=\"albedo\" sizedivisor=\"1 1\" format=\"rgba\" /\u0026gt;\n    \u0026lt;rendertarget name=\"normal\" sizedivisor=\"1 1\" format=\"rgba\" /\u0026gt;\n    \u0026lt;rendertarget name=\"depth\" sizedivisor=\"1 1\" format=\"lineardepth\" /\u0026gt;\n    \u0026lt;rendertarget name=\"fullscreen\" sizedivisor=\"1 1\" format=\"rgba\" filter=\"true\" /\u0026gt;\n    \u0026lt;command type=\"clear\" color=\"0 0 0 0\" depth=\"1.0\" stencil=\"0\" output=\"fullscreen\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"deferred\" vsdefines=\"VOLUMETRICLIGHT\" psdefines=\"VOLUMETRICLIGHT\" marktostencil=\"true\" vertexlights=\"true\" metadata=\"gbuffer\"\u0026gt;\n        \u0026lt;output index=\"0\" name=\"fullscreen\" /\u0026gt;\n        \u0026lt;output index=\"1\" name=\"albedo\" /\u0026gt;\n        \u0026lt;output index=\"2\" name=\"normal\" /\u0026gt;\n        \u0026lt;output index=\"3\" name=\"depth\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"lightvolumes\" vs=\"DeferredLight\" ps=\"DeferredLight\" vsdefines=\"VOLUMETRICLIGHT\" psdefines=\"VOLUMETRICLIGHT\" output=\"fullscreen\"\u0026gt;\n        \u0026lt;texture unit=\"albedo\" name=\"albedo\" /\u0026gt;\n        \u0026lt;texture unit=\"normal\" name=\"normal\" /\u0026gt;\n        \u0026lt;texture unit=\"depth\" name=\"depth\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;rendertarget name=\"blurv\" tag=\"Bloom\" sizedivisor=\"4 4\" format=\"rgb\" filter=\"true\" /\u0026gt;\n    \u0026lt;rendertarget name=\"blurh\" tag=\"Bloom\" sizedivisor=\"4 4\" format=\"rgb\" filter=\"true\" /\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BRIGHT VOLUMETRICLIGHT\" output=\"blurv\"\u0026gt;\n        \u0026lt;parameter name=\"BloomThreshold\" value=\"0.0\" /\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"fullscreen\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BLURH\" output=\"blurh\"\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"blurv\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"BLURV\" output=\"blurv\"\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"blurh\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"quad\" tag=\"Bloom\" vs=\"Bloom\" ps=\"Bloom\" psdefines=\"COMBINE\" output=\"viewport\"\u0026gt;\n        \u0026lt;parameter name=\"BloomMix\" value=\"1.0 1.0\" /\u0026gt;\n        \u0026lt;texture unit=\"diffuse\" name=\"fullscreen\" /\u0026gt;\n        \u0026lt;texture unit=\"normal\" name=\"blurv\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"postopaque\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"refract\"\u0026gt;\n        \u0026lt;texture unit=\"environment\" name=\"viewport\" /\u0026gt;\n    \u0026lt;/command\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"alpha\" vertexlights=\"true\" sort=\"backtofront\" metadata=\"alpha\" /\u0026gt;\n    \u0026lt;command type=\"scenepass\" pass=\"postalpha\" sort=\"backtofront\" /\u0026gt;\n\u0026lt;/renderpath\u0026gt;\n\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eBloom.glsl:\u003c/p\u003e\n\u003cp\u003e[code]\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúUniforms.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúSamplers.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúTransform.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúScreenPos.glsl‚Äù\u003c/p\u003e\n\u003cp\u003evarying vec2 vTexCoord;\u003cbr\u003e\nvarying vec2 vScreenPos;\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e COMPILEPS\u003cbr\u003e\nuniform float cBloomThreshold;\u003cbr\u003e\nuniform vec2 cBloomMix;\u003cbr\u003e\nuniform vec2 cBlurHInvSize;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003evoid VS()\u003cbr\u003e\n{\u003cbr\u003e\nmat4 modelMatrix = iModelMatrix;\u003cbr\u003e\nvec3 worldPos = GetWorldPos(modelMatrix);\u003cbr\u003e\ngl_Position = GetClipPos(worldPos);\u003cbr\u003e\nvTexCoord = GetQuadTexCoord(gl_Position);\u003cbr\u003e\nvScreenPos = GetScreenPosPreDiv(gl_Position);\u003cbr\u003e\n}\u003c/p\u003e\n\u003cp\u003evoid PS()\u003cbr\u003e\n{\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e BRIGHT\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifndef\u003c/span\u003e VOLUMETRICLIGHT\u003cbr\u003e\nvec3 rgb = texture2D(sDiffMap, vScreenPos).rgb;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvec3 rgb = texture2D(sDiffMap, vScreenPos).aaa;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\ngl_FragColor = vec4((rgb - vec3(cBloomThreshold, cBloomThreshold, cBloomThreshold)) / (1.0 - cBloomThreshold), 1.0);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e BLURH\u003cbr\u003e\nvec3 rgb = texture2D(sDiffMap, vTexCoord + vec2(-2.0, 0.0) * cBlurHInvSize).rgb * 0.1;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(-1.0, 0.0) * cBlurHInvSize).rgb * 0.25;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(0.0, 0.0) * cBlurHInvSize).rgb * 0.3;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(1.0, 0.0) * cBlurHInvSize).rgb * 0.25;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(2.0, 0.0) * cBlurHInvSize).rgb * 0.1;\u003cbr\u003e\ngl_FragColor = vec4(rgb, 1.0);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e BLURV\u003cbr\u003e\nvec3 rgb = texture2D(sDiffMap, vTexCoord + vec2(0.0, -2.0) * cBlurHInvSize).rgb * 0.1;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(0.0, -1.0) * cBlurHInvSize).rgb * 0.25;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(0.0, 0.0) * cBlurHInvSize).rgb * 0.3;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(0.0, 1.0) * cBlurHInvSize).rgb * 0.25;\u003cbr\u003e\nrgb += texture2D(sDiffMap, vTexCoord + vec2(0.0, 2.0) * cBlurHInvSize).rgb * 0.1;\u003cbr\u003e\ngl_FragColor = vec4(rgb, 1.0);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e COMBINE\u003cbr\u003e\nvec3 original = texture2D(sDiffMap, vScreenPos).rgb * cBloomMix.x;\u003cbr\u003e\nvec3 bloom = texture2D(sNormalMap, vTexCoord).rgb  * cBloomMix.y;\u003cbr\u003e\n// Prevent oversaturation\u003cbr\u003e\noriginal *= max(vec3(1.0) - bloom, vec3(0.0));\u003cbr\u003e\ngl_FragColor = vec4(original + bloom, 1.0);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n}\u003cbr\u003e\n[/code]\u003c/p\u003e\n\u003cp\u003eDeferredLight.glsl:\u003c/p\u003e\n\u003cp\u003e[code]\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúUniforms.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúSamplers.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúTransform.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúScreenPos.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúLighting.glsl‚Äù\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e DIRLIGHT\u003cbr\u003e\nvarying vec2 vScreenPos;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvarying vec4 vScreenPos;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\nvarying vec3 vFarRay;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ORTHO\u003cbr\u003e\nvarying vec3 vNearRay;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003evoid VS()\u003cbr\u003e\n{\u003cbr\u003e\nmat4 modelMatrix = iModelMatrix;\u003cbr\u003e\nvec3 worldPos = GetWorldPos(modelMatrix);\u003cbr\u003e\ngl_Position = GetClipPos(worldPos);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e DIRLIGHT\u003cbr\u003e\nvScreenPos = GetScreenPosPreDiv(gl_Position);\u003cbr\u003e\nvFarRay = GetFarRay(gl_Position);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ORTHO\u003cbr\u003e\nvNearRay = GetNearRay(gl_Position);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvScreenPos = GetScreenPos(gl_Position);\u003cbr\u003e\nvFarRay = GetFarRay(gl_Position) * gl_Position.w;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ORTHO\u003cbr\u003e\nvNearRay = GetNearRay(gl_Position) * gl_Position.w;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n}\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e SHADOW\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e VOLUMETRICLIGHT\u003cbr\u003e\nfloat ComputeScattering(float lightDotView)\u003cbr\u003e\n{\u003cbr\u003e\nconst float G_SCATTERING = 0.5;\u003cbr\u003e\nconst float PI = 3.14159265358979323846;\u003cbr\u003e\nfloat result = 1.0 - G_SCATTERING * G_SCATTERING;\u003cbr\u003e\nresult /= (4.0 * PI * pow(1.0 + G_SCATTERING * G_SCATTERING - (2.0 * G_SCATTERING) * lightDotView, 1.5));\u003cbr\u003e\nreturn result;\u003cbr\u003e\n}\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    float rand(highp vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n#endif\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003evoid PS()\u003cbr\u003e\n{\u003cbr\u003e\n// If rendering a directional light quad, optimize out the w divide\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e DIRLIGHT\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e HWDEPTH\u003cbr\u003e\nfloat depth = ReconstructDepth(texture2D(sDepthBuffer, vScreenPos).r);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nfloat depth = DecodeDepth(texture2D(sDepthBuffer, vScreenPos).rgb);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ORTHO\u003cbr\u003e\nvec3 worldPos = mix(vNearRay, vFarRay, depth);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvec3 worldPos = vFarRay * depth;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\nvec4 albedoInput = texture2D(sAlbedoBuffer, vScreenPos);\u003cbr\u003e\nvec4 normalInput = texture2D(sNormalBuffer, vScreenPos);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e HWDEPTH\u003cbr\u003e\nfloat depth = ReconstructDepth(texture2DProj(sDepthBuffer, vScreenPos).r);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nfloat depth = DecodeDepth(texture2DProj(sDepthBuffer, vScreenPos).rgb);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ORTHO\u003cbr\u003e\nvec3 worldPos = mix(vNearRay, vFarRay, depth) / vScreenPos.w;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvec3 worldPos = vFarRay * depth / vScreenPos.w;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\nvec4 albedoInput = texture2DProj(sAlbedoBuffer, vScreenPos);\u003cbr\u003e\nvec4 normalInput = texture2DProj(sNormalBuffer, vScreenPos);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Position acquired via near/far ray is relative to camera. Bring position to world space\nvec3 eyeVec = -worldPos;\nworldPos += cCameraPosPS;\n\nvec3 normal = normalize(normalInput.rgb * 2.0 - 1.0);\nvec4 projWorldPos = vec4(worldPos, 1.0);\nvec3 lightColor;\nvec3 lightDir;\n\nfloat diff = GetDiffuse(normal, worldPos, lightDir);\n\n#ifdef SHADOW\n    diff *= GetShadowDeferred(projWorldPos, normal, depth);\n    #ifdef VOLUMETRICLIGHT\n        highp vec3 rayDirection = normalize(worldPos-cCameraPosPS);\n        float accumFog = 0.0;\n        const int NB_STEPS = 15;\n        #ifdef DIRLIGHT\n            float ditherValue = rand(vScreenPos);\n        #else\n            float ditherValue = rand(vScreenPos.xy/vScreenPos.w);\n        #endif\n        for (int n = 0; n \u0026lt; NB_STEPS; n++) {\n            highp vec4 projWorldPosSpace = vec4(cCameraPosPS+(float(n)+ditherValue)*(worldPos-cCameraPosPS)/float(NB_STEPS), 1.0);\n            accumFog += GetShadowDeferred(projWorldPosSpace, vec3(0.0), float(n)*depth/float(NB_STEPS))*ComputeScattering(dot(rayDirection, lightDir));\n        }\n        accumFog /= float(NB_STEPS);\n    #endif\n#endif\n\n#if defined(SPOTLIGHT)\n    vec4 spotPos = projWorldPos * cLightMatricesPS[0];\n    lightColor = spotPos.w \u0026gt; 0.0 ? texture2DProj(sLightSpotMap, spotPos).rgb * cLightColor.rgb : vec3(0.0);\n#elif defined(CUBEMASK)\n    mat3 lightVecRot = mat3(cLightMatricesPS[0][0].xyz, cLightMatricesPS[0][1].xyz, cLightMatricesPS[0][2].xyz);\n    lightColor = textureCube(sLightCubeMap, (worldPos - cLightPosPS.xyz) * lightVecRot).rgb * cLightColor.rgb;\n#else\n    lightColor = cLightColor.rgb;\n#endif\n\n#ifdef SPECULAR\n    float spec = GetSpecular(normal, eyeVec, lightDir, normalInput.a * 255.0);\n    vec3 finalColor = diff * lightColor * (albedoInput.rgb + spec * cLightColor.a * albedoInput.aaa);\n#else\n    vec3 finalColor = diff * lightColor * albedoInput.rgb;\n#endif\n\nfloat finalAlpha = 0.0;\n#ifdef SHADOW\n    #ifdef VOLUMETRICLIGHT\n        finalAlpha = accumFog;\n    #endif\n#endif\n\ngl_FragColor = vec4(finalColor, finalAlpha);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}\u003cbr\u003e\n[/code]\u003c/p\u003e\n\u003cp\u003eLitSolid.glsl:\u003c/p\u003e\n\u003cp\u003e[code]\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúUniforms.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúSamplers.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúTransform.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúScreenPos.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúLighting.glsl‚Äù\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#include\u003c/span\u003e ‚ÄúFog.glsl‚Äù\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e NORMALMAP\u003cbr\u003e\nvarying vec4 vTexCoord;\u003cbr\u003e\nvarying vec4 vTangent;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvarying vec2 vTexCoord;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\nvarying vec3 vNormal;\u003cbr\u003e\nvarying vec4 vWorldPos;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e VERTEXCOLOR\u003cbr\u003e\nvarying vec4 vColor;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e PERPIXEL\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e SHADOW\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifndef\u003c/span\u003e GL_ES\u003cbr\u003e\nvarying vec4 vShadowPos[NUMCASCADES];\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e VOLUMETRICLIGHT\u003cbr\u003e\nvarying vec2 vScreenPos;\u003cbr\u003e\nvarying vec4 vShadowPosCamera[NUMCASCADES];\u003cbr\u003e\nvarying vec4 vShadowPosTarget[NUMCASCADES];\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvarying highp vec4 vShadowPos[NUMCASCADES];\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e VOLUMETRICLIGHT\u003cbr\u003e\nvarying highp vec2 vScreenPos;\u003cbr\u003e\nvarying highp vec4 vShadowPosCamera[NUMCASCADES];\u003cbr\u003e\nvarying highp vec4 vShadowPosTarget[NUMCASCADES];\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e SPOTLIGHT\u003cbr\u003e\nvarying vec4 vSpotPos;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e POINTLIGHT\u003cbr\u003e\nvarying vec3 vCubeMaskVec;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvarying vec3 vVertexLight;\u003cbr\u003e\nvarying vec4 vScreenPos;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ENVCUBEMAP\u003cbr\u003e\nvarying vec3 vReflectionVec;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#if\u003c/span\u003e defined(LIGHTMAP) || defined(AO)\u003cbr\u003e\nvarying vec2 vTexCoord2;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003evoid VS()\u003cbr\u003e\n{\u003cbr\u003e\nmat4 modelMatrix = iModelMatrix;\u003cbr\u003e\nvec3 worldPos = GetWorldPos(modelMatrix);\u003cbr\u003e\ngl_Position = GetClipPos(worldPos);\u003cbr\u003e\nvNormal = GetWorldNormal(modelMatrix);\u003cbr\u003e\nvWorldPos = vec4(worldPos, GetDepth(gl_Position));\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#ifdef VERTEXCOLOR\n    vColor = iColor;\n#endif\n\n#ifdef NORMALMAP\n    vec3 tangent = GetWorldTangent(modelMatrix);\n    vec3 bitangent = cross(tangent, vNormal) * iTangent.w;\n    vTexCoord = vec4(GetTexCoord(iTexCoord), bitangent.xy);\n    vTangent = vec4(tangent, bitangent.z);\n#else\n    vTexCoord = GetTexCoord(iTexCoord);\n#endif\n\n#ifdef PERPIXEL\n    // Per-pixel forward lighting\n    vec4 projWorldPos = vec4(worldPos, 1.0);\n\n    #ifdef SHADOW\n        // Shadow projection: transform from world space to shadow space\n        for (int i = 0; i \u0026lt; NUMCASCADES; i++)\n            vShadowPos[i] = GetShadowPos(i, vNormal, projWorldPos);\n        #ifdef VOLUMETRICLIGHT\n            // Shadow projection: transform from world space to shadow space\n            for (int i = 0; i \u0026lt; NUMCASCADES; i++)\n                vShadowPosCamera[i] = GetShadowPos(i, vec3(0), vec4(cCameraPos, 1.0));\n            // Shadow projection: transform from world space to shadow space\n            for (int i = 0; i \u0026lt; NUMCASCADES; i++)\n                vShadowPosTarget[i] = GetShadowPos(i, vec3(0), projWorldPos);\n            vScreenPos = GetScreenPosPreDiv(gl_Position);\n        #endif\n    #endif\n\n    #ifdef SPOTLIGHT\n        // Spotlight projection: transform from world space to projector texture coordinates\n        vSpotPos = projWorldPos * cLightMatrices[0];\n    #endif\n\n    #ifdef POINTLIGHT\n        vCubeMaskVec = (worldPos - cLightPos.xyz) * mat3(cLightMatrices[0][0].xyz, cLightMatrices[0][1].xyz, cLightMatrices[0][2].xyz);\n    #endif\n#else\n    // Ambient \u0026amp; per-vertex lighting\n    #if defined(LIGHTMAP) || defined(AO)\n        // If using lightmap, disregard zone ambient light\n        // If using AO, calculate ambient in the PS\n        vVertexLight = vec3(0.0, 0.0, 0.0);\n        vTexCoord2 = iTexCoord1;\n    #else\n        vVertexLight = GetAmbient(GetZonePos(worldPos));\n    #endif\n    \n    #ifdef NUMVERTEXLIGHTS\n        for (int i = 0; i \u0026lt; NUMVERTEXLIGHTS; ++i)\n            vVertexLight += GetVertexLight(i, worldPos, vNormal) * cVertexLights[i * 3].rgb;\n    #endif\n    \n    vScreenPos = GetScreenPos(gl_Position);\n\n    #ifdef ENVCUBEMAP\n        vReflectionVec = worldPos - cCameraPos;\n    #endif\n#endif\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e SHADOW\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e VOLUMETRICLIGHT\u003cbr\u003e\nfloat ComputeScattering(float lightDotView)\u003cbr\u003e\n{\u003cbr\u003e\nconst float G_SCATTERING = 0.5;\u003cbr\u003e\nconst float PI = 3.14159265358979323846;\u003cbr\u003e\nfloat result = 1.0 - G_SCATTERING * G_SCATTERING;\u003cbr\u003e\nresult /= (4.0 * PI * pow(1.0 + G_SCATTERING * G_SCATTERING - (2.0 * G_SCATTERING) * lightDotView, 1.5));\u003cbr\u003e\nreturn result;\u003cbr\u003e\n}\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    float rand(highp vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n#endif\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003evoid PS()\u003cbr\u003e\n{\u003cbr\u003e\n// Get material diffuse albedo\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e DIFFMAP\u003cbr\u003e\nvec4 diffInput = texture2D(sDiffMap, vTexCoord.xy);\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#ifdef\u003c/span\u003e ALPHAMASK\u003cbr\u003e\nif (diffInput.a \u0026lt; 0.5)\u003cbr\u003e\ndiscard;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003cbr\u003e\nvec4 diffColor = cMatDiffColor * diffInput;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#else\u003c/span\u003e\u003cbr\u003e\nvec4 diffColor = cMatDiffColor;\u003cbr\u003e\n\u003cspan class=\"hashtag\"\u003e#endif\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#ifdef VERTEXCOLOR\n    diffColor *= vColor;\n#endif\n\n// Get material specular albedo\n#ifdef SPECMAP\n    vec3 specColor = cMatSpecColor.rgb * texture2D(sSpecMap, vTexCoord.xy).rgb;\n#else\n    vec3 specColor = cMatSpecColor.rgb;\n#endif\n\n// Get normal\n#ifdef NORMALMAP\n    mat3 tbn = mat3(vTangent.xyz, vec3(vTexCoord.zw, vTangent.w), vNormal);\n    vec3 normal = normalize(tbn * DecodeNormal(texture2D(sNormalMap, vTexCoord.xy)));\n#else\n    vec3 normal = normalize(vNormal);\n#endif\n\n// Get fog factor\n#ifdef HEIGHTFOG\n    float fogFactor = GetHeightFogFactor(vWorldPos.w, vWorldPos.y);\n#else\n    float fogFactor = GetFogFactor(vWorldPos.w);\n#endif\n\n#if defined(PERPIXEL)\n    // Per-pixel forward lighting\n    vec3 lightColor;\n    vec3 lightDir;\n    vec3 finalColor;\n\n    float diff = GetDiffuse(normal, vWorldPos.xyz, lightDir);\n\n    #ifdef SHADOW\n        diff *= GetShadow(vShadowPos, vWorldPos.w);\n        #ifdef VOLUMETRICLIGHT\n            highp vec3 rayDirection = normalize(vWorldPos.xyz-cCameraPosPS);\n            float accumFog = 0.0;\n            const int NB_STEPS = 15;\n            float ditherValue = rand(vScreenPos);\n            for (int n = 0; n \u0026lt; NB_STEPS; n++) {\n                highp vec4 vShadowPosSpace[NUMCASCADES];\n                for (int i = 0; i \u0026lt; NUMCASCADES; i++) {\n                    vShadowPosSpace[i] = vShadowPosCamera[i]+(float(n)+ditherValue)*(vShadowPosTarget[i]-vShadowPosCamera[i])/float(NB_STEPS);\n                }\n                accumFog += GetShadow(vShadowPosSpace, float(n)*vWorldPos.w/float(NB_STEPS))*ComputeScattering(dot(rayDirection, lightDir));\n            }\n            accumFog /= float(NB_STEPS);\n        #endif\n    #endif\n\n    #if defined(SPOTLIGHT)\n        lightColor = vSpotPos.w \u0026gt; 0.0 ? texture2DProj(sLightSpotMap, vSpotPos).rgb * cLightColor.rgb : vec3(0.0, 0.0, 0.0);\n    #elif defined(CUBEMASK)\n        lightColor = textureCube(sLightCubeMap, vCubeMaskVec).rgb * cLightColor.rgb;\n    #else\n        lightColor = cLightColor.rgb;\n    #endif\n\n    #ifdef SPECULAR\n        float spec = GetSpecular(normal, cCameraPosPS - vWorldPos.xyz, lightDir, cMatSpecColor.a);\n        finalColor = diff * lightColor * (diffColor.rgb + spec * specColor * cLightColor.a);\n    #else\n        finalColor = diff * lightColor * diffColor.rgb;\n    #endif\n\n    #ifdef AMBIENT\n        finalColor += cAmbientColor.rgb * diffColor.rgb;\n        finalColor += cMatEmissiveColor;\n        finalColor = GetFog(finalColor, fogFactor);\n    #else\n        finalColor = GetLitFog(finalColor, fogFactor);\n    #endif\n\n    #ifndef VOLUMETRICLIGHT\n        float finalAlpha = diffColor.a;\n    #else\n        float finalAlpha = 0.0;\n    #endif\n\n    #ifdef SHADOW\n        #ifdef VOLUMETRICLIGHT\n            finalAlpha = accumFog;\n        #endif\n    #endif\n    gl_FragColor = vec4(finalColor, finalAlpha);\n#elif defined(PREPASS)\n    // Fill light pre-pass G-Buffer\n    float specPower = cMatSpecColor.a / 255.0;\n\n    gl_FragData[0] = vec4(normal * 0.5 + 0.5, specPower);\n    gl_FragData[1] = vec4(EncodeDepth(vWorldPos.w), 0.0);\n#elif defined(DEFERRED)\n    // Fill deferred G-buffer\n    float specIntensity = specColor.g;\n    float specPower = cMatSpecColor.a / 255.0;\n\n    vec3 finalColor = vVertexLight * diffColor.rgb;\n    #ifdef AO\n        // If using AO, the vertex light ambient is black, calculate occluded ambient here\n        finalColor += texture2D(sEmissiveMap, vTexCoord2).rgb * cAmbientColor.rgb * diffColor.rgb;\n    #endif\n\n    #ifdef ENVCUBEMAP\n        finalColor += cMatEnvMapColor * textureCube(sEnvCubeMap, reflect(vReflectionVec, normal)).rgb;\n    #endif\n    #ifdef LIGHTMAP\n        finalColor += texture2D(sEmissiveMap, vTexCoord2).rgb * diffColor.rgb;\n    #endif\n    #ifdef EMISSIVEMAP\n        finalColor += cMatEmissiveColor * texture2D(sEmissiveMap, vTexCoord.xy).rgb;\n    #else\n        finalColor += cMatEmissiveColor;\n    #endif\n\n    #ifndef VOLUMETRICLIGHT\n        gl_FragData[0] = vec4(GetFog(finalColor, fogFactor), 1.0);\n    #else\n        gl_FragData[0] = vec4(GetFog(finalColor, fogFactor), 0.0);\n    #endif\n    gl_FragData[1] = fogFactor * vec4(diffColor.rgb, specIntensity);\n    gl_FragData[2] = vec4(normal * 0.5 + 0.5, specPower);\n    gl_FragData[3] = vec4(EncodeDepth(vWorldPos.w), 0.0);\n#else\n    // Ambient \u0026amp; per-vertex lighting\n    vec3 finalColor = vVertexLight * diffColor.rgb;\n    #ifdef AO\n        // If using AO, the vertex light ambient is black, calculate occluded ambient here\n        finalColor += texture2D(sEmissiveMap, vTexCoord2).rgb * cAmbientColor.rgb * diffColor.rgb;\n    #endif\n    \n    #ifdef MATERIAL\n        // Add light pre-pass accumulation result\n        // Lights are accumulated at half intensity. Bring back to full intensity now\n        vec4 lightInput = 2.0 * texture2DProj(sLightBuffer, vScreenPos);\n        vec3 lightSpecColor = lightInput.a * lightInput.rgb / max(GetIntensity(lightInput.rgb), 0.001);\n\n        finalColor += lightInput.rgb * diffColor.rgb + lightSpecColor * specColor;\n    #endif\n\n    #ifdef ENVCUBEMAP\n        finalColor += cMatEnvMapColor * textureCube(sEnvCubeMap, reflect(vReflectionVec, normal)).rgb;\n    #endif\n    #ifdef LIGHTMAP\n        finalColor += texture2D(sEmissiveMap, vTexCoord2).rgb * diffColor.rgb;\n    #endif\n    #ifdef EMISSIVEMAP\n        finalColor += cMatEmissiveColor * texture2D(sEmissiveMap, vTexCoord.xy).rgb;\n    #else\n        finalColor += cMatEmissiveColor;\n    #endif\n\n    gl_FragColor = vec4(GetFog(finalColor, fogFactor), diffColor.a);\n#endif\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}\u003cbr\u003e\n[/code]\u003c/p\u003e","post_number":4,"post_type":1,"updated_at":"2017-01-02T01:15:02.511Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":39,"reads":66,"readers_count":65,"score":225.2,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"link_counts":[{"url":"https://youtu.be/ZkkazPduyW4","internal":false,"reflection":false,"title":"volumetric lighting - YouTube","clicks":111},{"url":"https://youtu.be/ZkkazPduyW4%5B/video%5D","internal":false,"reflection":false,"clicks":16}],"read":true,"user_title":null,"bookmarked":false,"actions_summary":[{"id":2,"count":1}],"moderator":false,"admin":false,"staff":false,"user_id":546,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14298,"name":"","username":"franck22000","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/f/f4b2a3/{size}.png","created_at":"2016-11-04T10:19:24.000Z","cooked":"\u003cp\u003eExcellent, looking forward to see if you are able to port it for deferred rendering.\u003c/p\u003e","post_number":5,"post_type":1,"updated_at":"2017-01-02T01:15:02.817Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":46,"readers_count":45,"score":9.2,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":174,"hidden":false,"trust_level":1,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14314,"name":"","username":"artgolf1000","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","created_at":"2016-11-05T05:09:16.000Z","cooked":"\u003cp\u003eThe deferred mode is ready, it support both forward lighting mode and deferred lighting mode now!\u003c/p\u003e\n\u003cp\u003eI have to use the alpha channel to store volumetric lighting value, it may cause alpha lighting incorrect, if this happens, put ‚Äòvsexcludes=‚ÄúVOLUMETRICLIGHT‚Äù‚Äô and ‚Äòpsexcludes=‚ÄúVOLUMETRICLIGHT‚Äù‚Äô to the litalpha and light pass, such as ‚ÄòDiffAlpha.xml‚Äô, it should solve the issue.\u003c/p\u003e\n\u003cp\u003eI can not figure out how to let lighting pass support multiple render target at present.\u003c/p\u003e","post_number":6,"post_type":1,"updated_at":"2017-01-02T01:15:03.879Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":47,"readers_count":46,"score":9.4,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":546,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14319,"name":"","username":"dragonCASTjosh","avatar_template":"/user_avatar/discourse.urho3d.io/dragoncastjosh/{size}/774_2.png","created_at":"2016-11-05T17:11:03.000Z","cooked":"\u003cp\u003eDoes it support the PBR render path? because i think it would look amazing alongside PBR\u003c/p\u003e","post_number":7,"post_type":1,"updated_at":"2017-01-02T01:15:04.222Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":51,"readers_count":50,"score":10.2,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":284,"hidden":false,"trust_level":3,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14327,"name":"","username":"artgolf1000","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","created_at":"2016-11-06T05:09:32.000Z","cooked":"\u003cp\u003eI am not familiar with PBR, you may look into DeferredLight.glsl, I guess it not difficult to port to PBR.\u003c/p\u003e","post_number":8,"post_type":1,"updated_at":"2017-01-02T01:15:04.790Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":1,"reads":48,"readers_count":47,"score":14.6,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":546,"hidden":false,"trust_level":2,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false},{"id":14350,"name":"","username":"dragonCASTjosh","avatar_template":"/user_avatar/discourse.urho3d.io/dragoncastjosh/{size}/774_2.png","created_at":"2016-11-06T23:57:26.000Z","cooked":"\u003cp\u003eas long as it doesnt make changes to the diffuse or specular then i dont see it causing a problem to implement\u003c/p\u003e","post_number":9,"post_type":1,"updated_at":"2017-01-02T01:15:06.348Z","reply_count":0,"reply_to_post_number":null,"quote_count":0,"incoming_link_count":0,"reads":47,"readers_count":46,"score":9.4,"yours":false,"topic_id":2373,"topic_slug":"volumetric-lighting","display_username":"","primary_group_name":null,"flair_name":null,"flair_url":null,"flair_bg_color":null,"flair_color":null,"version":1,"can_edit":false,"can_delete":false,"can_recover":false,"can_wiki":false,"read":true,"user_title":null,"bookmarked":false,"actions_summary":[],"moderator":false,"admin":false,"staff":false,"user_id":284,"hidden":false,"trust_level":3,"deleted_at":null,"user_deleted":false,"edit_reason":null,"can_view_edit_history":true,"wiki":false,"can_accept_answer":false,"can_unaccept_answer":false,"accepted_answer":false}],"stream":[14287,14288,14289,14294,14298,14314,14319,14327,14350]},"timeline_lookup":[[1,2211],[4,2210],[6,2209],[7,2208],[9,2207]],"suggested_topics":[{"id":7122,"title":"Faster allocations with PMR","fancy_title":"Faster allocations with PMR","slug":"faster-allocations-with-pmr","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2022-01-10T16:23:15.053Z","last_posted_at":"2022-01-10T16:42:29.752Z","bumped":true,"bumped_at":"2022-01-10T17:55:02.117Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":209,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":1363,"username":"vmost","name":null,"avatar_template":"https://avatars.discourse-cdn.com/v4/letter/v/5f9b8f/{size}.png"}}]},{"id":7101,"title":"Unique Per-Node Shader Uniform for Model-Particles","fancy_title":"Unique Per-Node Shader Uniform for Model-Particles","slug":"unique-per-node-shader-uniform-for-model-particles","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2021-12-16T03:16:09.579Z","last_posted_at":"2021-12-16T09:40:41.978Z","bumped":true,"bumped_at":"2021-12-16T09:40:41.978Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":0,"views":139,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":192,"username":"Modanung","name":"È≠îÂ§ßÂÜú ùûçùûéùù≥ ÁèæÊãõËúç","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}}]},{"id":7062,"title":"Is WebGL2.0 \u0026 GLES3.0 being supported in the near future?","fancy_title":"Is WebGL2.0 \u0026amp; GLES3.0 being supported in the near future?","slug":"is-webgl2-0-gles3-0-being-supported-in-the-near-future","posts_count":2,"reply_count":0,"highest_post_number":2,"image_url":null,"created_at":"2021-11-23T09:04:28.802Z","last_posted_at":"2021-11-23T21:44:08.088Z","bumped":true,"bumped_at":"2021-11-23T21:44:08.088Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":199,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":1490,"username":"Sunc","name":"DoubleSuper","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/df788c/{size}.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":631,"username":"JTippetts1","name":"J Tippetts","avatar_template":"/user_avatar/discourse.urho3d.io/jtippetts1/{size}/96_2.png"}}]},{"id":7119,"title":"How to programmatically access Morph Target in FBX file?","fancy_title":"How to programmatically access Morph Target in FBX file?","slug":"how-to-programmatically-access-morph-target-in-fbx-file","posts_count":13,"reply_count":8,"highest_post_number":13,"image_url":null,"created_at":"2022-01-03T23:01:43.070Z","last_posted_at":"2022-01-05T11:55:31.130Z","bumped":true,"bumped_at":"2022-01-05T11:55:31.130Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":214,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":null,"description":"Original Poster","user":{"id":1499,"username":"csteaderman","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/c/b487fb/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":628,"username":"SirNate0","name":"SirNate0","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/s/9f8e36/{size}.png"}},{"extras":null,"description":"Frequent Poster","user":{"id":484,"username":"Eugene","name":"Eugene Kozlov","avatar_template":"/user_avatar/discourse.urho3d.io/eugene/{size}/902_2.png"}},{"extras":"latest","description":"Most Recent Poster","user":{"id":192,"username":"Modanung","name":"È≠îÂ§ßÂÜú ùûçùûéùù≥ ÁèæÊãõËúç","avatar_template":"/user_avatar/discourse.urho3d.io/modanung/{size}/3290_2.png"}}]},{"id":7136,"title":"Open-source ocean shader system","fancy_title":"Open-source ocean shader system","slug":"open-source-ocean-shader-system","posts_count":1,"reply_count":0,"highest_post_number":1,"image_url":null,"created_at":"2022-01-19T23:11:15.784Z","last_posted_at":"2022-01-19T23:11:15.858Z","bumped":true,"bumped_at":"2022-01-19T23:11:15.858Z","archetype":"regular","unseen":false,"pinned":false,"unpinned":null,"visible":true,"closed":false,"archived":false,"bookmarked":null,"liked":null,"tags_descriptions":{},"like_count":1,"views":177,"category_id":16,"featured_link":null,"has_accepted_answer":false,"posters":[{"extras":"latest single","description":"Original Poster, Most Recent Poster","user":{"id":1304,"username":"lebrewer","name":"lebrewer","avatar_template":"/user_avatar/discourse.urho3d.io/lebrewer/{size}/2811_2.png"}}]}],"tags_descriptions":{},"id":2373,"title":"Volumetric Lighting","fancy_title":"Volumetric Lighting","posts_count":9,"created_at":"2016-11-03T07:39:46.000Z","views":1904,"reply_count":0,"like_count":1,"last_posted_at":"2016-11-06T23:57:26.000Z","visible":true,"closed":false,"archived":false,"has_summary":false,"archetype":"regular","slug":"volumetric-lighting","category_id":16,"word_count":2629,"deleted_at":null,"user_id":546,"featured_link":null,"pinned_globally":false,"pinned_at":null,"pinned_until":null,"image_url":null,"slow_mode_seconds":0,"draft":null,"draft_key":"topic_2373","draft_sequence":null,"unpinned":null,"pinned":false,"current_post_number":1,"highest_post_number":9,"deleted_by":null,"actions_summary":[{"id":4,"count":0,"hidden":false,"can_act":false},{"id":8,"count":0,"hidden":false,"can_act":false},{"id":7,"count":0,"hidden":false,"can_act":false}],"chunk_size":20,"bookmarked":false,"bookmarks":[],"topic_timer":null,"message_bus_last_id":0,"participant_count":3,"show_read_indicator":false,"thumbnails":null,"slow_mode_enabled_until":null,"tags_disable_ads":false,"details":{"can_edit":false,"notification_level":1,"participants":[{"id":546,"username":"artgolf1000","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png","post_count":5,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":2},{"id":174,"username":"franck22000","name":"","avatar_template":"https://avatars.discourse-cdn.com/v4/letter/f/f4b2a3/{size}.png","post_count":2,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":1},{"id":284,"username":"dragonCASTjosh","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/dragoncastjosh/{size}/774_2.png","post_count":2,"primary_group_name":null,"flair_name":null,"flair_url":null,"flair_color":null,"flair_bg_color":null,"trust_level":3}],"created_by":{"id":546,"username":"artgolf1000","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/artgolf1000/{size}/73_2.png"},"last_poster":{"id":284,"username":"dragonCASTjosh","name":"","avatar_template":"/user_avatar/discourse.urho3d.io/dragoncastjosh/{size}/774_2.png"},"links":[{"url":"https://youtu.be/ZkkazPduyW4","title":"volumetric lighting - YouTube","internal":false,"attachment":false,"reflection":false,"clicks":111,"user_id":546,"domain":"youtu.be","root_domain":"youtu.be"},{"url":"http://www.alexandre-pestana.com/volumetric-lights/","title":null,"internal":false,"attachment":false,"reflection":false,"clicks":73,"user_id":546,"domain":"www.alexandre-pestana.com","root_domain":"alexandre-pestana.com"},{"url":"https://youtu.be/ZkkazPduyW4%5B/video%5D","title":null,"internal":false,"attachment":false,"reflection":false,"clicks":16,"user_id":546,"domain":"youtu.be","root_domain":"youtu.be"},{"url":"http://discourse.urho3d.io/t/anyone-could-use-urho3d-depth-on-raymarching-in-shaders/3084/2","title":"Anyone could use Urho3D Depth on Raymarching in Shaders?","internal":true,"attachment":false,"reflection":true,"clicks":1,"user_id":546,"domain":"discourse.urho3d.io","root_domain":"urho3d.io"}]}}